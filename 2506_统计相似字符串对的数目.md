[[2506.统计相似字符串对的数目]](https://leetcode.cn/problems/count-pairs-of-similar-strings)

```cpp
class Solution {
public:
    int similarPairs(vector<string>& words) {
        unordered_map<int,int>cnt;
        int ans=0;
        for(string& word : words) {
            int mask=0;
            for(char c : word) {
                mask|=1<<(c-'a');
            } 
            ans+=cnt[mask]++;
        }
        return ans;
    }
};
```

#### 一、mask 的核心定义与设计原理

1. **本质**：`mask`是一个整型变量（通常为 int，32 位），核心作用是**用二进制位编码字符串的字符集合（去重后）**，实现对 “字符串包含哪些小写字母” 的高效表示。

2. 设计思路：

   - 小写字母共 26 个（a-z），int 类型的 32 位二进制足够容纳这 26 个标识位；
   - 二进制位与字母的映射规则：第 0 位（最低位）对应 a，第 1 位对应 b，……，第 25 位对应 z；
   - 二进制位的含义：某一位为 1 → 字符串包含对应字母；为 0 → 不包含。

   

#### 二、mask 的生成与核心操作拆解

|    操作步骤     |       代码       |                           详细说明                           |                   示例（以字符 'b' 为例）                    |                                   |                    |
| :-------------: | :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------: | :----------------: |
|    1. 初始化    | `int mask = 0;`  | 初始值为 0，二进制全 0（`000...0000`），表示 “未标记任何字母” |                   mask=0 → 二进制`...0000`                   |                                   |                    |
|   2. 字符映射   |    `c - 'a'`     | 将字符 c 转换为 0-25 的数字（a→0，b→1，…，z→25），定位该字符对应的二进制位 |                  'b'-'a' = 1 → 对应第 1 位                   |                                   |                    |
|  3. 生成位标识  | `1 << (c - 'a')` | 将数字 1 左移对应位数，得到 “仅当前字母对应位为 1，其余位为 0” 的整数 |                 1 << 1 = 2 → 二进制`...0010`                 |                                   |                    |
| 4. 标记字符存在 |      `mask       |                         = 上述结果 `                         | 按位或操作：保留 mask 原有 1 的位，同时将当前字母对应位设为 1（重复字符不改变 mask，实现自动去重） | 若 mask 原 = 1（`...0001`），则 1 | 2 = 3（`...0011`） |

#### 三、mask 的匹配规则

- 核心规则：

  字符组成（去重后）完全相同的字符串，生成的 mask 值必然相同

  ；字符组成不同的字符串，mask 值必然不同。

  - 示例 1："ab"、"ba"、"aab" → 去重后都是 {a,b} → mask=3（二进制`...0011`）；
  - 示例 2："ac" → 去重后 {a,c} → mask=5（二进制`...0101`），与 "ab" 的 mask 不同。

#### 四、mask 在代码中的完整应用逻辑（统计同类字符串数对）

```
ans += cnt[mask]++;
```

1. **cnt 的作用**：`cnt`是数组 / 哈希表，键为 mask 值，值为该 mask 已出现的次数（即对应字符组成的字符串已出现的次数）；
2. 统计逻辑拆解：
   - 处理第 1 个字符串：`cnt[mask]`初始为 0 → `ans += 0`（无匹配数对），然后`cnt[mask]++`（标记该 mask 出现 1 次）；
   - 处理第 2 个同 mask 字符串：`cnt[mask]`为 1 → `ans += 1`（统计 1 对），然后`cnt[mask]++`（标记出现 2 次）；
   - 处理第 3 个同 mask 字符串：`cnt[mask]`为 2 → `ans += 2`（新增 2 对：与第 1、2 个分别配对），然后`cnt[mask]++`；
   - 最终`ans`为所有同类字符串的数对总数（组合数：n*(n-1)/2）。

#### 五、mask 方案的核心优势

1. **空间高效**：用 1 个整数代替字符串 / 集合存储字符信息，占用内存远小于直接存储字符集合；
2. **时间高效**：二进制位操作（左移、按位或）是 CPU 原生高效操作，比遍历 / 哈希判断字符组成快；
3. **匹配高效**：判断两个字符串字符组成是否相同，只需比较 mask 值（O (1)），无需逐个字符比对（O (n)）。