[[1339.分裂二叉树的最大乘积]](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/)

```cpp
class Solution {
public:
    long long total=0; //整棵树和
    long long best=0; // 最大乘积

    // dfs整棵树求和
    long long sumTree(TreeNode* node) {
        if(!node) return 0;
            return (long long)node->val+sumTree(node->left)+sumTree(node->right);
    }   
    // dfs求子树和 更新best
    long long sumSubTree(TreeNode* node) {
        if(!node) return 0;
        long long s=(long long)node->val+sumSubTree(node->left)+sumSubTree(node->right);
        // 切断node与父节点之间那条边:一边是S 另一边是total-s
        long long prod=s*(total-s);
        best=max(best,prod);
        return s;
    }
    int maxProduct(TreeNode* root) {
        const int MOL=1e9+7;
        total=sumTree(root);
        best=0;
        sumSubTree(root);
        return (int)(best%MOL);
    }
};
```

第一次 DFS：计算整棵树的点权和 total。

第二次 DFS：计算子树点权和 s，那么删除当前节点到其父节点的边后，另一部分的和就是 total−s，二者乘积为

s⋅(total−s)
用其更新答案的最大值。

由于本题保证点权是非负，我们无需判断当前节点是根节点的特殊情况（无父节点），此时上式为 0，不影响答案。

如果有负数点权，就需要跳过当前节点是根节点的情况。
