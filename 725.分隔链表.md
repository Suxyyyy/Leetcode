[[725.分隔链表]](https://leetcode.cn/problems/split-linked-list-in-parts/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        vector<ListNode*>ans;
        ListNode* cur=head;
        int length=0;
        while(cur) {
            cur=cur->next;
            ++length;
        }
        cur=head;
        while(k) {
            int divLen=(length+k-1)/k; // 向上取整 本次分割的长度
            length-=divLen; //剩余长度
            ListNode* tmp=new ListNode();
            ListNode* thead=tmp;
            if(divLen==0) thead=nullptr;
            else {
                while(divLen--) {
                    if(!cur) {
                        thead=nullptr;
                        break;
                    }
                    else {
                        tmp->val=cur->val;
                        if(divLen>0 && cur->next) {
                            ListNode* a=new ListNode();
                            a->val=cur->next->val;
                            tmp->next=a;
                            tmp=tmp->next;
                        }
                        cur=cur->next;
                    }
                }
            }
            ans.push_back(thead);
            --k;
        }
        return ans;
    }
};
```

先对链表进行一次扫描，得到总长度 cnt，再结合需要将将链表划分为 k 份，可知每一份的 最小 分配单位 per=⌊ k/cnt ⌋（当 cnt<k 时，per 为 0）。

然后从前往后切割出 k 份链表，由于是在原链表的基础上进行，因此这里的切分只需要在合适的位置将节点的 next 指针置空即可。

当我们需要构造出 ans[i] 的链表长度时，首先可以先分配 per 的长度，如果 已处理的链表长度 + 剩余待分配份数 * per < cnt，说明后面「待分配的份数」如果按照每份链表分配 per 长度的话，会有节点剩余，基于「不能均分时，前面的应当比后面长」原则，此时只需为当前 ans[i] 多分一个单位长度即可。

- 时间复杂度：*O*(*n*)
- 空间复杂度：*O*(1)

