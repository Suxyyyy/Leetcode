[[865.具有所有最深节点的最小子树]](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int max_depth = -1; // 全局最大深度
    TreeNode* ans;
    // depth当前节点所在深度（根为 0）
    int dfs(TreeNode* node,int depth) {
        if(!node) {
            max_depth=max(max_depth,depth);
            return depth;
        }
        int left_max_depth=dfs(node->left,depth+1);
        int right_max_depth=dfs(node->right,depth+1);
        if(left_max_depth==right_max_depth && left_max_depth==max_depth) ans=node;
        return max(left_max_depth,right_max_depth);
    }
    TreeNode* subtreeWithAllDeepest(TreeNode* root) {
        dfs(root,0);
        return ans;
    }
};
```

#### （1）递归出口

```
if (!node) {
    max_depth = max(max_depth, depth);
    return depth;
}
```

- 空节点代表“走到底了”
- 用 `depth` 更新全局最大深度

------

#### （2）递归左右子树

```c++
int left_max = dfs(node->left, depth + 1);
int right_max = dfs(node->right, depth + 1);
```

------

#### （3）答案判断（核心）

```c++
if (left_max == right_max && left_max == max_depth)
    ans = node;
```

含义：

- 左右子树 **都到达了全局最深层**
- 说明 **所有最深节点第一次在此汇合**
- 当前节点即为 **包含所有最深节点的最小子树根**

------

#### （4）向上返回

```c++
return max(left_max, right_max);
```

## 复杂度分析

- **时间复杂度**：`O(N)`（每个节点访问一次）

- **空间复杂度**：`O(H)`（递归栈，最坏 `O(N)`）
