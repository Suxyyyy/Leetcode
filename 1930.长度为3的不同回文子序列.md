[[1930.长度为3的不同回文子序列]](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/description/)
```cpp
class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int ans=0;
        for (char alpha='a';alpha<='z';alpha++) { // 枚举两侧字母alpha
            int i=s.find(alpha); // 最左边的alpha的下标
            if (i==string::npos) { // s中没有alpha
                continue;
            }
            int j=s.rfind(alpha); // 最右边的alpha的下标

            bool has[26]{};
            for (int k=i+1;k<j;k++) { // 枚举中间字母 s[k]
                if (!has[s[k]-'a']) {
                    has[s[k]-'a']=true; // 防止重复统计
                    ans++;
                }
            }
        }
        return ans;
    }
};
```
**枚举两侧**
枚举子序列的第一、三个字母是` a,b,…,z`。

如果第一、三个字母都是 a，如何找到尽量多的不同的子序列？

例如` s=abbacad`。如果选前两个 a 作为子序列的第一、三个字母，我们只能找到子序列 `aba`。而如果选第一个 a 和最后一个 a，夹在两个 a 之间的字母都可以是子序列的第二个字母，从而找到第一、三个字母都是 a 的所有子序列，即 `aaa、aba 和 aca。`

**算法：**
枚举 `α=a,b,…,z`。
找 α 在 s 中首次出现的下标 i 和最后一次出现的下标 j。如果没有这样的下标，回到第一步继续枚举。
下标在` [i+1,j−1] `中的字母，可以作为回文子序列的中间字母。
题目要求相同的子序列只计数一次。这可以用哈希集合去重，也可以用长为 26 的布尔数组记录遇到过的中间字母，避免重复统计。
