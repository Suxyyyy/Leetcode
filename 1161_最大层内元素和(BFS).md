[[1161.最大层内元素和]](https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/)

```cpp
class Solution {
public:
    int maxLevelSum(TreeNode* root) {
        // ans: 记录最大和所在的层号
        // max_sum: 记录当前发现的最大层之和，初始化为最小整数
        int ans = 0;
        int max_sum = INT_MIN;
        // 使用 vector 模拟队列进行层序遍历
        vector<TreeNode*> q = {root};
        // 从第 1 层开始遍历，直到队列为空
        for (int level = 1; !q.empty(); level++) {
            // 【关键】将当前层的节点转移到 tmp，清空 q 准备接收下一层子节点
            auto tmp = move(q);
            int current_level_sum = 0; 
            // 遍历当前层的所有节点
            for (auto node : tmp) {
                current_level_sum += node->val; // 累加当前层的值
                // 将下一层的子节点加入队列 q
                if (node->left) {
                    q.push_back(node->left);
                }
                if (node->right) {
                    q.push_back(node->right);
                }
            }
            // 如果当前层的和严格大于历史最大值，则更新结果
            if (current_level_sum > max_sum) {
                max_sum = current_level_sum;
                ans = level;
            }
        }
        return ans;
    }
};
```

### 1. 算法思路

该算法采用 **广度优先搜索 (BFS)**。

- **层序访问**：使用一个队列（代码中用 `vector` 配合 `move` 模拟）逐层访问节点。
- **水平求和**：在访问每一层时，累加该层所有节点的值。
- **状态更新**：维护一个全局最大和 `max_sum` 及其对应的层号 `ans`。如果当前层之和大于 `max_sum`，则进行更新。

### 2. 复杂度分析

- **时间复杂度**：O(N)，其中 N 是树中的节点总数。每个节点仅被入队和出队一次。
- **空间复杂度**：O(W)，其中 W 是树的最大宽度。在最坏情况下（满二叉树），最后一层的节点数约为 N/2。

### 3. 代码关键点

- **`std::move(q)`**：这是一种高效的技巧。通过移动语义将旧队列清空并转移给临时变量 `tmp`，避免了频繁的内存分配，同时腾出 `q` 用于存储下一层的节点。
- **初始化**：`max_sum` 初始化为 `INT_MIN` 是为了处理节点值全部为负数的情况。