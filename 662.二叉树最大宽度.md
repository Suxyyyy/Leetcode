[[662.二叉树最大宽度]](https://leetcode.cn/problems/maximum-width-of-binary-tree/description/)

```cpp
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        // 空树宽度为0，边界判断
        if(!root) return 0;
        unsigned long long maxWidth = 0; // 存储最大宽度，用ull防溢出
        // pair<当前节点, 当前节点的编号>
        // 编号规则：完全二叉树规则，用来计算包含空节点的真实宽度
        queue<pair<TreeNode*, unsigned long long>> q;
        q.push({root, 1}); // 根节点是第1个节点，编号初始化=1【编号规则起点】

        // 层序遍历BFS：一层一层遍历二叉树，标准固定写法
        while(!q.empty()) {
            int levelSize = q.size(); // 记录当前层的节点数量，必须先存
            unsigned long long leftIdx = q.front().second; // 本层最左侧节点的编号
            unsigned long long rightIdx = q.back().second; // 本层最右侧节点的编号

            // 计算当前层宽度 + 更新最大宽度
            // 宽度 = 最右编号 - 最左编号 + 1
            maxWidth = max(maxWidth, rightIdx - leftIdx + 1);

            // 遍历当前层的所有节点，给子节点编号并入队
            for(int i = 0; i < levelSize; ++i) {
                auto curNodePair = q.front();
                q.pop();
                TreeNode* node = curNodePair.first;   // 取出当前遍历的节点
                unsigned long long curIdx = curNodePair.second; // 取出当前节点的编号
                if(node->left)  q.push({node->left,  curIdx * 2});    // 左孩子编号 = 父节点*2
                if(node->right) q.push({node->right, curIdx * 2 + 1});// 右孩子编号 = 父节点*2 + 1
            }
        }
        return maxWidth;
    }
};
```

二叉树的**真实宽度**：包含层内最左到最右的**所有空节点占位**，不是单纯的节点个数，必须用**编号法**计算；

编号规则：根节点 = 1，左孩子 = 父节点 ×2，右孩子 = 父节点 ×2+1，这个规则是死的，永远不变；

层宽度公式：`当前层宽度 = 本层最右编号 - 本层最左编号 + 1`，取所有层宽度的最大值就是答案。

**变量类型必须用`unsigned long long`**

> 原因：二叉树层级深时，编号 `idx*2` 会指数级增大，`int`会溢出变成负数，导致计算宽度出错

**必须先存`levelSize = q.size()`**

> 原因：队列在遍历过程中会不断`push`子节点，`q.size()`会实时变化，如果不先存，遍历的次数会出错