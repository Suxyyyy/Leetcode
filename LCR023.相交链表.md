[[LCR023.相交链表]](https://leetcode.cn/problems/3u1WK4/description/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* p=headA;
        ListNode* q=headB;
        while(p!=q) {
            p=p?p->next:headB;
            q=q?q->next:headA;
        }
        return p;
    }
};
```

定义两个指针 `p`、`q`，分别从 `headA`、`headB` 出发，**同步向后遍历**：

1. 指针走到自己链表的末尾（`NULL`）时，不停止，而是「跳转到」另一个链表的头结点，继续遍历；
2. 两个指针最终会在 **相交节点处相遇** 或 **同时走到两个链表的末尾（NULL）**；
3. 相遇时，指针指向的节点就是目标相交节点；同时为 NULL 时，说明无相交。

- 时间复杂度：O(m+n) （m、n 分别为两个链表的长度，仅遍历最多两轮）
- 空间复杂度：O(1) （只定义了 2 个指针，无额外空间开销，最优核心）